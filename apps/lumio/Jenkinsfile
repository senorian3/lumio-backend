pipeline {
    agent any
    
    environment {
        ENV_TYPE = "production"
        PORT = 4121
        NAMESPACE = "lumio-su"
        REGISTRY_HOSTNAME = "senorian3"
        PROJECT = "lumio-back-end"
        SERVICE = "lumio"
        REGISTRY = "registry.hub.docker.com"
        DEPLOYMENT_NAME = "lumio-back-end-deployment"
        IMAGE_NAME = "${env.BUILD_ID}_${env.ENV_TYPE}_${env.GIT_COMMIT}"
        DOCKER_BUILD_NAME = "${env.REGISTRY_HOSTNAME}/${env.PROJECT}:${env.IMAGE_NAME}"
        
        // –î–ª—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è
        YARN_CACHE_DIR = "${WORKSPACE}/.yarn-cache"
        PRISMA_CACHE_DIR = "${WORKSPACE}/.prisma-cache"
        
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–∫—Ä—É–∂–µ–Ω–∏–µ –¥–ª—è –∫–æ–º–∞–Ω–¥
        NODE_ENV = "production"
    }
    
    stages {
        stage('Clone repository') {
            steps {
                checkout scm
                
                sh '''
                    echo "=== Repository Info ==="
                    echo "Commit: ${GIT_COMMIT}"
                    echo "Branch: ${GIT_BRANCH}"
                    echo "Build: ${BUILD_NUMBER}"
                    echo "Workspace: ${WORKSPACE}"
                '''
            }
        }
        
        stage('Check prerequisites') {
    steps {
        script {
            sh '''
                echo "=== Quick prerequisites check ==="
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º Docker (—Å–∞–º–æ–µ –≤–∞–∂–Ω–æ–µ)
                if ! docker --version > /dev/null 2>&1; then
                    echo "‚ùå FATAL: Docker not found or not working"
                    exit 1
                fi
                echo "‚úÖ Docker: $(docker --version | head -1)"
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º Node.js
                if ! node --version > /dev/null 2>&1; then
                    echo "‚ö†Ô∏è Node.js not in PATH, checking NVM..."
                    if [ -s "$HOME/.nvm/nvm.sh" ]; then
                        . "$HOME/.nvm/nvm.sh"
                        nvm use default 2>/dev/null || true
                    fi
                    
                    if ! node --version > /dev/null 2>&1; then
                        echo "‚ùå FATAL: Node.js not found"
                        exit 1
                    fi
                fi
                echo "‚úÖ Node.js: $(node --version)"
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º Yarn
                if ! yarn --version > /dev/null 2>&1; then
                    echo "‚ö†Ô∏è Yarn not found, installing..."
                    npm install -g yarn 2>/dev/null || echo "‚ö†Ô∏è Could not install yarn"
                else
                    echo "‚úÖ Yarn: $(yarn --version)"
                fi
                
                echo "‚úÖ Prerequisites OK"
            '''
        }
    }
}
        
        stage('Clean and setup workspace') {
            steps {
                sh '''
                    echo "=== Cleaning workspace ==="
                    
                    # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ node_modules –∏ –±–∏–ª–¥—ã
                    find . -name "node_modules" -type d -prune -exec rm -rf {} + 2>/dev/null || true
                    find . -name "dist" -type d -prune -exec rm -rf {} + 2>/dev/null || true
                    find . -name ".next" -type d -prune -exec rm -rf {} + 2>/dev/null || true
                    find . -name "coverage" -type d -prune -exec rm -rf {} + 2>/dev/null || true
                    
                    # –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –¥–ª—è –∫—ç—à–∞
                    mkdir -p ${YARN_CACHE_DIR}
                    mkdir -p ${PRISMA_CACHE_DIR}
                    
                    echo "‚úÖ Workspace cleaned and cache directories created"
                '''
            }
        }
        
        stage('Install dependencies with smart cache') {
            steps {
                script {
                    sh '''
                        echo "=== Installing dependencies ==="
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º package.json
                        if [ ! -f "package.json" ]; then
                            echo "‚ùå package.json not found!"
                            exit 1
                        fi
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–µ–º –ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫—ç—à
                        CACHE_VALID=false
                        if [ -f "${YARN_CACHE_DIR}/package.json" ]; then
                            echo "Found cached package.json, comparing..."
                            
                            # –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ö—ç—à–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
                            CURRENT_DEPS_HASH=$(cat package.json | grep -E '"dependencies"|"devDependencies"' | sort | md5sum | cut -d' ' -f1 2>/dev/null || echo "no_hash")
                            CACHED_DEPS_HASH=$(cat ${YARN_CACHE_DIR}/package.json | grep -E '"dependencies"|"devDependencies"' | sort | md5sum | cut -d' ' -f1 2>/dev/null || echo "no_hash")
                            
                            if [ "${CURRENT_DEPS_HASH}" = "${CACHED_DEPS_HASH}" ]; then
                                echo "‚úÖ Dependencies unchanged, using cache"
                                
                                # –ö–æ–ø–∏—Ä—É–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–æ–¥—É–ª–∏
                                if [ -d "${YARN_CACHE_DIR}/node_modules" ]; then
                                    echo "Copying cached node_modules..."
                                    cp -r ${YARN_CACHE_DIR}/node_modules . || true
                                fi
                                
                                CACHE_VALID=true
                            else
                                echo "‚ö†Ô∏è Dependencies changed, need fresh install"
                            fi
                        fi
                        
                        if [ "${CACHE_VALID}" = "false" ]; then
                            echo "Installing fresh dependencies..."
                            
                            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º
                            yarn install --frozen-lockfile --cache-folder ${YARN_CACHE_DIR} --prefer-offline --network-timeout 600000 || {
                                echo "‚ùå Failed to install dependencies"
                                exit 1
                            }
                            
                            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫—ç—à
                            echo "Caching dependencies..."
                            cp package.json ${YARN_CACHE_DIR}/ 2>/dev/null || true
                            cp yarn.lock ${YARN_CACHE_DIR}/ 2>/dev/null || true
                            
                            # –ö–æ–ø–∏—Ä—É–µ–º node_modules –≤ –∫—ç—à (–±–µ–∑ symlinks)
                            echo "Caching node_modules..."
                            rm -rf ${YARN_CACHE_DIR}/node_modules 2>/dev/null || true
                            mkdir -p ${YARN_CACHE_DIR}/node_modules
                            
                            # –ö–æ–ø–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –æ—Å–Ω–æ–≤–Ω—ã–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞
                            for dir in @nestjs @prisma @types date-fns; do
                                if [ -d "node_modules/${dir}" ]; then
                                    cp -r "node_modules/${dir}" "${YARN_CACHE_DIR}/node_modules/" 2>/dev/null || true
                                fi
                            done
                        fi
                        
                        echo "‚úÖ Dependencies installed"
                    '''
                }
            }
        }
        
        stage('Code quality checks') {
            steps {
                script {
                    sh '''
                        echo "=== Running code quality checks ==="
                        
                        # –ó–∞–ø—É—Å–∫–∞–µ–º –ª–∏–Ω—Ç–∏–Ω–≥
                        echo "Running ESLint..."
                        yarn lint 2>/dev/null || {
                            echo "‚ö†Ô∏è ESLint found issues or not configured"
                        }
                        
                        # –ó–∞–ø—É—Å–∫–∞–µ–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
                        echo "Running Prettier..."
                        yarn format 2>/dev/null || {
                            echo "‚ö†Ô∏è Prettier found issues or not configured"
                        }
                        
                        echo "‚úÖ Code quality checks completed"
                    '''
                }
            }
        }
        
        stage('Build application') {
            steps {
                script {
                    sh '''
                        echo "=== Building application ==="
                        
                        # –°–æ–±–∏—Ä–∞–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å
                        echo "Building ${SERVICE} service..."
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–∫—Ä—É–∂–µ–Ω–∏–µ
                        ENV_FILE="apps/${SERVICE}/.env.${SERVICE}.${ENV_TYPE}"
                        if [ ! -f "${ENV_FILE}" ]; then
                            echo "‚ö†Ô∏è Environment file not found: ${ENV_FILE}"
                            echo "Using development environment file..."
                            ENV_FILE="apps/${SERVICE}/.env.${SERVICE}.development"
                        fi
                        
                        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º Prisma –∫–ª–∏–µ–Ω—Ç —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –æ–∫—Ä—É–∂–µ–Ω–∏–µ–º
                        echo "Generating Prisma client..."
                        
                        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à –¥–ª—è Prisma –µ—Å–ª–∏ –µ—Å—Ç—å
                        if [ -d "${PRISMA_CACHE_DIR}/prisma" ]; then
                            echo "Using cached Prisma client..."
                            mkdir -p ./node_modules/.prisma
                            cp -r ${PRISMA_CACHE_DIR}/prisma/* ./node_modules/.prisma/ 2>/dev/null || true
                        fi
                        
                        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º Prisma –∫–ª–∏–µ–Ω—Ç
                        if [ "${SERVICE}" = "lumio" ]; then
                            yarn prisma:generate:lumio 2>/dev/null || {
                                echo "‚ùå Failed to generate Prisma client"
                                exit 1
                            }
                        elif [ "${SERVICE}" = "files" ]; then
                            yarn prisma:generate:files 2>/dev/null || {
                                echo "‚ùå Failed to generate Prisma client"
                                exit 1
                            }
                        fi
                        
                        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫—ç—à
                        if [ -d "./node_modules/.prisma" ]; then
                            echo "Caching Prisma client..."
                            mkdir -p ${PRISMA_CACHE_DIR}/prisma
                            cp -r ./node_modules/.prisma/* ${PRISMA_CACHE_DIR}/prisma/ 2>/dev/null || true
                        fi
                        
                        # –°–æ–±–∏—Ä–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
                        echo "Building NestJS application..."
                        if [ "${SERVICE}" = "lumio" ]; then
                            yarn build:lumio || {
                                echo "‚ùå Failed to build lumio"
                                exit 1
                            }
                        elif [ "${SERVICE}" = "files" ]; then
                            yarn build:files || {
                                echo "‚ùå Failed to build files"
                                exit 1
                            }
                        fi
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –±–∏–ª–¥–∞
                        if [ ! -d "dist/apps/${SERVICE}" ]; then
                            echo "‚ùå Build output not found at dist/apps/${SERVICE}"
                            exit 1
                        fi
                        
                        echo "‚úÖ Application built successfully"
                    '''
                }
            }
        }
        
        stage('Run tests') {
            steps {
                script {
                    sh '''
                        echo "=== Running tests ==="
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ—Å—Ç–æ–≤–æ–µ –æ–∫—Ä—É–∂–µ–Ω–∏–µ
                        TEST_ENV_FILE="apps/${SERVICE}/.env.${SERVICE}.testing"
                        if [ ! -f "${TEST_ENV_FILE}" ]; then
                            echo "‚ö†Ô∏è Test environment file not found: ${TEST_ENV_FILE}"
                            echo "Skipping tests..."
                        else
                            # –ó–∞–ø—É—Å–∫–∞–µ–º unit —Ç–µ—Å—Ç—ã
                            echo "Running unit tests for ${SERVICE}..."
                            
                            if [ "${SERVICE}" = "lumio" ]; then
                                yarn test:unit:lumio --passWithNoTests --coverage || {
                                    echo "‚ö†Ô∏è Unit tests failed or no tests found"
                                }
                            else
                                yarn test:unit --passWithNoTests || {
                                    echo "‚ö†Ô∏è Unit tests failed or no tests found"
                                }
                            fi
                            
                            # –ó–∞–ø—É—Å–∫–∞–µ–º e2e —Ç–µ—Å—Ç—ã –µ—Å–ª–∏ –µ—Å—Ç—å
                            echo "Running e2e tests..."
                            if [ "${SERVICE}" = "lumio" ]; then
                                yarn test:e2e:lumio 2>/dev/null || {
                                    echo "‚ö†Ô∏è E2E tests failed or not configured"
                                }
                            fi
                        fi
                        
                        echo "‚úÖ Tests completed"
                    '''
                }
            }
            
            post {
                always {
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ç—á–µ—Ç—ã –æ –ø–æ–∫—Ä—ã—Ç–∏–∏
                    junit '**/test-results.xml'
                    archiveArtifacts 'coverage/**/*'
                }
            }
        }
        
        stage('Build Docker image') {
            steps {
                script {
                    echo "=== Building Docker image ==="
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º Dockerfile
                    def dockerfile = "./apps/${SERVICE}/Dockerfile"
                    if (!fileExists(dockerfile)) {
                        error "‚ùå Dockerfile not found: ${dockerfile}"
                    }
                    
                    // –ü–æ–ª—É—á–∞–µ–º –≤–µ—Ä—Å–∏—é –∏–∑ package.json
                    def packageJson = readJSON file: 'package.json'
                    def version = packageJson.version ?: '1.0.0'
                    
                    // –ì–æ—Ç–æ–≤–∏–º –±–∏–ª–¥-–∞—Ä–≥—É–º–µ–Ω—Ç—ã
                    def buildArgs = [
                        "--build-arg SERVICE=${SERVICE}",
                        "--build-arg PORT=${PORT}",
                        "--build-arg VERSION=${version}",
                        "--build-arg BUILD_NUMBER=${env.BUILD_NUMBER}",
                        "--build-arg GIT_COMMIT=${env.GIT_COMMIT}",
                        "--build-arg NODE_ENV=${NODE_ENV}",
                        "--label version=${version}",
                        "--label build.number=${env.BUILD_NUMBER}",
                        "--label commit=${env.GIT_COMMIT}",
                        "--label service=${SERVICE}",
                        "--label environment=${ENV_TYPE}"
                    ].join(' ')
                    
                    // –°–æ–±–∏—Ä–∞–µ–º –æ–±—Ä–∞–∑
                    echo "Building image: ${DOCKER_BUILD_NAME}"
                    echo "Build args: ${buildArgs}"
                    
                    app = docker.build(
                        "${DOCKER_BUILD_NAME}",
                        "${buildArgs} -f ${dockerfile} ./"
                    )
                    
                    echo "‚úÖ Docker image built successfully"
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä –æ–±—Ä–∞–∑–∞
                    sh '''
                        echo "=== Image information ==="
                        docker images ${DOCKER_BUILD_NAME} --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–ª–æ–∏
                        docker history ${DOCKER_BUILD_NAME} --format "table {{.CreatedBy}}\t{{.Size}}" --no-trunc | head -10
                    '''
                }
            }
        }
        
        stage('Push Docker image') {
            steps {
                script {
                    echo "=== Pushing Docker image ==="
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å registry
                    sh '''
                        echo "Testing Docker registry connection..."
                        docker login ${REGISTRY} -u lumio-su --password-stdin <<< "${DOCKER_PASSWORD}" 2>/dev/null || {
                            echo "‚ö†Ô∏è Could not login to registry, but trying to push anyway"
                        }
                    '''
                    
                    docker.withRegistry("https://${REGISTRY}", 'lumio-su') {
                        // –û—Å–Ω–æ–≤–Ω–æ–π push
                        app.push("${IMAGE_NAME}")
                        
                        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ç–µ–≥–∏
                        def packageJson = readJSON file: 'package.json'
                        def version = packageJson.version ?: '1.0.0'
                        
                        // –î–ª—è production –ø—É—à–∏–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ç–µ–≥–∏
                        if (ENV_TYPE == "production") {
                            app.push("latest")
                            app.push("v${version}")
                            app.push("production-${version}")
                            echo "‚úÖ Pushed additional tags: latest, v${version}, production-${version}"
                        }
                        
                        // –î–ª—è staging
                        if (ENV_TYPE == "staging") {
                            app.push("staging")
                            app.push("staging-${version}")
                        }
                    }
                    
                    echo "‚úÖ Docker image pushed successfully"
                }
            }
        }
        
        stage('Clean local Docker images') {
            steps {
                sh '''
                    echo "=== Cleaning local Docker images ==="
                    
                    # –£–¥–∞–ª—è–µ–º —Å–æ–±—Ä–∞–Ω–Ω—ã–π –æ–±—Ä–∞–∑
                    docker rmi -f ${DOCKER_BUILD_NAME} 2>/dev/null || true
                    
                    # –£–¥–∞–ª—è–µ–º dangling images
                    docker image prune -f 2>/dev/null || true
                    
                    # –£–¥–∞–ª—è–µ–º –Ω–µ–Ω—É–∂–Ω—ã–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã
                    docker container prune -f 2>/dev/null || true
                    
                    echo "‚úÖ Local Docker cleanup completed"
                '''
            }
        }
        
        stage('Prepare Kubernetes deployment') {
            steps {
                script {
                    echo "=== Preparing Kubernetes deployment ==="
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–∫—Ä–∏–ø—Ç –¥–µ–ø–ª–æ—è
                    def deployScript = "./apps/${SERVICE}/preparingDeploy.sh"
                    if (!fileExists(deployScript)) {
                        error "‚ùå Deploy script not found: ${deployScript}"
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ–Ω executable
                    sh """
                        echo "Checking deploy script..."
                        ls -la ${deployScript}
                        
                        if [ ! -x "${deployScript}" ]; then
                            echo "Making deploy script executable..."
                            chmod +x ${deployScript}
                        fi
                    """
                    
                    // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–∫—Ä–∏–ø—Ç
                    sh """
                        echo "Running deploy script..."
                        ./apps/${SERVICE}/preparingDeploy.sh \\
                            "${REGISTRY_HOSTNAME}" \\
                            "${PROJECT}" \\
                            "${IMAGE_NAME}" \\
                            "${DEPLOYMENT_NAME}" \\
                            "${PORT}" \\
                            "${NAMESPACE}"
                        
                        echo "=== Generated deployment.yaml ==="
                        DEPLOYMENT_FILE="./apps/${SERVICE}/deployment.yaml"
                        
                        if [ -f "\${DEPLOYMENT_FILE}" ]; then
                            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
                            cat "\${DEPLOYMENT_FILE}"
                            
                            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ image —É–∫–∞–∑–∞–Ω –ø—Ä–∞–≤–∏–ª—å–Ω–æ
                            if ! grep -q "${IMAGE_NAME}" "\${DEPLOYMENT_FILE}"; then
                                echo "‚ö†Ô∏è Warning: Image name not found in deployment.yaml"
                            fi
                        else
                            echo "‚ùå deployment.yaml not generated!"
                            exit 1
                        fi
                    """
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    echo "=== Deploying to Kubernetes ==="
                    
                    withKubeConfig([credentialsId: 'prod-kubernetes']) {
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∫–ª–∞—Å—Ç–µ—Ä—É
                        sh '''
                            echo "Checking Kubernetes connection..."
                            
                            if ! kubectl cluster-info; then
                                echo "‚ùå Cannot connect to Kubernetes cluster"
                                exit 1
                            fi
                            
                            echo "Kubernetes nodes:"
                            kubectl get nodes --no-headers | wc -l || echo "0"
                        '''
                        
                        // –ü—Ä–∏–º–µ–Ω—è–µ–º –¥–µ–ø–ª–æ–π–º–µ–Ω—Ç
                        sh """
                            echo "Applying deployment to namespace ${NAMESPACE}..."
                            
                            DEPLOYMENT_FILE="./apps/${SERVICE}/deployment.yaml"
                            
                            # Dry-run —Å–Ω–∞—á–∞–ª–∞
                            kubectl apply -f "\${DEPLOYMENT_FILE}" --namespace=${NAMESPACE} --dry-run=client
                            
                            # –ü—Ä–∏–º–µ–Ω—è–µ–º
                            kubectl apply -f "\${DEPLOYMENT_FILE}" --namespace=${NAMESPACE}
                            
                            echo "Watching rollout status..."
                            
                            # –ñ–¥–µ–º rollout —Å —Ç–∞–π–º–∞—É—Ç–æ–º
                            timeout=300
                            interval=5
                            elapsed=0
                            
                            while [ \$elapsed -lt \$timeout ]; do
                                status=\$(kubectl rollout status deployment/${DEPLOYMENT_NAME} \\
                                    --namespace=${NAMESPACE} \\
                                    --timeout=60s 2>&1 || true)
                                
                                if echo "\$status" | grep -q "successfully rolled out"; then
                                    echo "‚úÖ Deployment rolled out successfully"
                                    break
                                fi
                                
                                echo "Waiting for rollout... (\$elapsed/\$timeout seconds)"
                                sleep \$interval
                                elapsed=\$((elapsed + interval))
                            done
                            
                            if [ \$elapsed -ge \$timeout ]; then
                                echo "‚ö†Ô∏è Rollout timeout reached"
                            fi
                            
                            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å
                            echo "=== Deployment details ==="
                            kubectl get deployment/${DEPLOYMENT_NAME} \\
                                --namespace=${NAMESPACE} \\
                                -o wide
                            
                            echo "=== Pods status ==="
                            kubectl get pods \\
                                --namespace=${NAMESPACE} \\
                                -l app=${DEPLOYMENT_NAME} \\
                                -o wide
                            
                            echo "=== Services ==="
                            kubectl get services \\
                                --namespace=${NAMESPACE} \\
                                -o wide
                            
                            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–æ–≥–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø–æ–¥–∞
                            echo "=== Recent pod logs ==="
                            POD_NAME=\$(kubectl get pods \\
                                --namespace=${NAMESPACE} \\
                                -l app=${DEPLOYMENT_NAME} \\
                                -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
                            
                            if [ -n "\${POD_NAME}" ]; then
                                echo "Logs from pod: \${POD_NAME}"
                                kubectl logs \${POD_NAME} \\
                                    --namespace=${NAMESPACE} \\
                                    --tail=20 2>/dev/null || echo "Could not get logs"
                            fi
                        """
                    }
                    
                    echo "‚úÖ Kubernetes deployment completed"
                }
            }
        }
        
        stage('Post-deployment verification') {
            steps {
                script {
                    echo "=== Post-deployment verification ==="
                    
                    // –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –∑–∞–ø—É—Å–∫
                    sleep 20
                    
                    withKubeConfig([credentialsId: 'prod-kubernetes']) {
                        sh """
                            echo "Checking deployment health..."
                            
                            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –ø–æ–¥–æ–≤
                            READY=\$(kubectl get deployment ${DEPLOYMENT_NAME} \\
                                --namespace=${NAMESPACE} \\
                                -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
                            
                            DESIRED=\$(kubectl get deployment ${DEPLOYMENT_NAME} \\
                                --namespace=${NAMESPACE} \\
                                -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "0")
                            
                            echo "Ready replicas: \${READY}/\${DESIRED}"
                            
                            if [ "\${READY}" -eq "\${DESIRED}" ] && [ "\${READY}" -gt "0" ]; then
                                echo "‚úÖ All pods are ready"
                                
                                # –ü—ã—Ç–∞–µ–º—Å—è —Å–¥–µ–ª–∞—Ç—å health check
                                echo "Attempting health check..."
                                
                                # –ü–æ–ª—É—á–∞–µ–º service IP –∏–ª–∏ hostname
                                SERVICE_INFO=\$(kubectl get svc ${DEPLOYMENT_NAME} \\
                                    --namespace=${NAMESPACE} \\
                                    -o jsonpath='{.status.loadBalancer.ingress[0].hostname}{" "}{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
                                
                                if [ -n "\${SERVICE_INFO}" ]; then
                                    echo "Service endpoint: \${SERVICE_INFO}"
                                    # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å curl –ø—Ä–æ–≤–µ—Ä–∫—É
                                    # curl -f http://\${SERVICE_INFO}:${PORT}/health || echo "Health check failed"
                                fi
                            else
                                echo "‚ö†Ô∏è Not all pods are ready"
                                
                                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–±—ã—Ç–∏—è
                                echo "Recent events:"
                                kubectl get events \\
                                    --namespace=${NAMESPACE} \\
                                    --field-selector involvedObject.name=${DEPLOYMENT_NAME} \\
                                    --sort-by='.lastTimestamp' \\
                                    --tail=10 2>/dev/null || true
                                
                                # –õ–æ–≥–∏ –ø—Ä–æ–±–ª–µ–º–Ω—ã—Ö –ø–æ–¥–æ–≤
                                echo "Logs from failing pods:"
                                kubectl get pods \\
                                    --namespace=${NAMESPACE} \\
                                    -l app=${DEPLOYMENT_NAME} \\
                                    --field-selector=status.phase!=Running \\
                                    -o name | head -3 | while read pod; do
                                    echo "=== Logs for \$pod ==="
                                    kubectl logs \$pod --namespace=${NAMESPACE} --tail=50 2>/dev/null || echo "Could not get logs"
                                done
                            fi
                        """
                    }
                    
                    echo "‚úÖ Post-deployment verification completed"
                }
            }
        }
    }
    
    post {
        always {
            echo "=== Pipeline execution completed ==="
            echo "Job: ${JOB_NAME}"
            echo "Build: ${BUILD_NUMBER}"
            echo "Result: ${currentBuild.result}"
            echo "Duration: ${currentBuild.durationString}"
            echo "Commit: ${GIT_COMMIT}"
            echo "Branch: ${GIT_BRANCH}"
            echo "Image: ${DOCKER_BUILD_NAME}"
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã
            archiveArtifacts artifacts: '**/coverage/**/*', allowEmptyArchive: true
            archiveArtifacts artifacts: '**/*.log', allowEmptyArchive: true
            archiveArtifacts artifacts: '**/deployment.yaml', allowEmptyArchive: true
        }
        
        success {
            echo "üéâ Pipeline SUCCESS!"
            
            sh '''
                echo "========================================"
                echo "SUCCESSFUL DEPLOYMENT"
                echo "========================================"
                echo "Service: ${SERVICE}"
                echo "Environment: ${ENV_TYPE}"
                echo "Image: ${DOCKER_BUILD_NAME}"
                echo "Namespace: ${NAMESPACE}"
                echo "Deployment: ${DEPLOYMENT_NAME}"
                echo "========================================"
            '''
        }
        
        failure {
            echo "üí• Pipeline FAILED!"
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –±–æ–ª—å—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
            sh '''
                echo "=== Debug information ==="
                echo "Disk space:"
                df -h 2>/dev/null || true
                
                echo "Memory usage:"
                free -h 2>/dev/null || true
                
                echo "Docker status:"
                docker ps -a 2>/dev/null | head -20 || true
                
                echo "Recent Docker images:"
                docker images 2>/dev/null | head -20 || true
                
                echo "Workspace contents:"
                ls -la ${WORKSPACE} 2>/dev/null | head -20 || true
            '''
        }
        
        cleanup {
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫—ç—à –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –±–∏–ª–¥–∞
            sh '''
                echo "=== Final cleanup ==="
                echo "Preserving cache directories..."
                du -sh ${YARN_CACHE_DIR} 2>/dev/null || echo "Yarn cache not found"
                du -sh ${PRISMA_CACHE_DIR} 2>/dev/null || echo "Prisma cache not found"
                
                # –û—á–∏—â–∞–µ–º workspace –Ω–æ –æ—Å—Ç–∞–≤–ª—è–µ–º –∫—ç—à
                find . -maxdepth 1 ! -name ".yarn-cache" ! -name ".prisma-cache" ! -name "." -exec rm -rf {} + 2>/dev/null || true
                
                echo "Cleanup completed"
            '''
        }
    }
}